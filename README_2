

I have created a sudoku solving function that uses depth-first search, backtracking, and constraint propagation. Depth-first search fully explores one possibility before trying any other. For solving of sudoku, finding the conclusion of entering one value that is not certain and continuing to complete the sudoku until it is complete or there are no other possible values. When a not possible state is reached, the concept of backtracking is used, the function ‘backtracks’ to the last decision made and tries another option. In relation to sudoku, values are returned to 0 or an alternative possible value is used. Constraint propagation is beneficial in solving sudoku problems as for each number that is inserted, other possibilities are removed and therefore code run time is minimised. For sudoku, instead of trying every possible configuration of digits from 1 to 9 and finding a solution, only values that meet the rules of the sudoku game are considered. 

My implementation of these approaches as a sudoku solving function is as follows. The function starts by finding all of the empty cells starting with the top left. Each square in the sudoku has been assigned a coordinate, the empty function returns a list of coordinates. Utilising constraint propagation, the valid function finds all possible values of this empty cell. Now there is a list of empty cell coordinates followed by their possible values. 

In the simplest case, there is just one possibility for each cell. The function iterates through the coordinates and possible values list, entering each value into the sudoku, and the sudoku is solved. If there is more than one possible option for the cell, the function will insert the first value. Using the append function, the cell coordinates and the value entered will be stored in a list denoted visited, the coordinates and all possible values will be added to a list denoted stack. The function continues to fill in the sudoku having placed this ‘guess’. The function checks at each stage if the entry is valid. Although the possibilities were valid at the start of the function, due to entering further numbers, some possibilities can now be eliminated, utilising constraint propagation again.

If the attempted value does now not comply with the constraints, the backtracking part of the function begins. Using the stored stack and the function pop, the function iterates through the previous cells where it has placed numbers. If there are no other possibilities the cell is reverted to 0 until a cell is found with alternative options. The possible options are checked with visited list to see if there is a possibility that is yet to be searched, this is the new value. The sudoku continues to be filled with this new value. This part of the code uses recursion as it runs the sudoku solve function when already inside the function, this time starting with a partial solution from the already filled in values. If all possibilities have been attempted, the final part of the function checks that each col and row and box has no duplicate values and then will return the solved sudoku or an error message if no solution is possible. 

I decided to use a stack and visited list structure as it enabled easy error detection and the ability for me to follow the path of the function as it was inserting values into the sudoku and adding and subtracting values from the stack and visited lists. This was beneficial whilst trying to streamline the code and to understand what the code was doing at each stage. My code successfully solves 12/15 medium puzzles. The 3 where the output is not solvable, actually when dissecting the code is able to produce the correct answer but my code fails to realise this and output the correct solution. Therefore possible refinements of my code would be to ensure that if a correct solution is found at any point, this correct solution will be returned. 
